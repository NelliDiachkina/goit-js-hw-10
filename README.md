# goit-js-hw-10

## Завдання 1 - Таймер зворотного відліку

Виконуй це завдання у файлах `1-timer.html` і `1-timer.js`. Напиши скрипт
таймера, який здійснює зворотний відлік до певної дати. Такий таймер може
використовуватися у блогах, інтернет-магазинах, сторінках реєстрації подій, під
час технічного обслуговування тощо. Подивися демовідео роботи таймера.




https://github.com/NelliDiachkina/goit-js-hw-10/assets/99911692/d93e19f5-b528-49d3-b333-370216d18b57





#### Елементи інтерфейсу

Додай в HTML файл розмітку таймера, поля вибору кінцевої дати і кнопку, при
кліку на яку таймер повинен запускатися. Додай оформлення елементів інтерфейсу
згідно з макетом.

```js
<input type="text" id="datetime-picker" />
<button type="button" data-start>Start</button>

<div class="timer">
  <div class="field">
    <span class="value" data-days>00</span>
    <span class="label">Days</span>
  </div>
  <div class="field">
    <span class="value" data-hours>00</span>
    <span class="label">Hours</span>
  </div>
  <div class="field">
    <span class="value" data-minutes>00</span>
    <span class="label">Minutes</span>
  </div>
  <div class="field">
    <span class="value" data-seconds>00</span>
    <span class="label">Seconds</span>
  </div>
</div>
```

#### Бібліотека `flatpickr`

Використовуй бібліотеку [flatpickr](https://flatpickr.js.org/) для того, щоб
дозволити користувачеві кросбраузерно вибрати кінцеву дату і час в одному
елементі інтерфейсу. Для того щоб підключити CSS код бібліотеки в проєкт,
необхідно додати ще один імпорт, крім того, що описаний в документації.

```js
// Описаний в документації
import flatpickr from 'flatpickr';
// Додатковий імпорт стилів
import 'flatpickr/dist/flatpickr.min.css';
```

Бібліотека очікує, що її ініціалізують на елементі `input[type="text"]`, тому ми
додали до HTML документа поле `input#datetime-picker`.

```js
<input type="text" id="datetime-picker" />
```

Другим аргументом функції `flatpickr(selector, options)` можна передати
необов'язковий об'єкт параметрів. Ми підготували для тебе об'єкт, який потрібен
для виконання завдання. Розберися, за що відповідає кожна властивість у
[документації «Options»](https://flatpickr.js.org/options/) і використовуй його
у своєму коді.

```js
const options = {
  enableTime: true,
  time_24hr: true,
  defaultDate: new Date(),
  minuteIncrement: 1,
  onClose(selectedDates) {
    console.log(selectedDates[0]);
  },
};
```

#### Вибір дати

Метод `onClose()` з об'єкта параметрів викликається щоразу під час закриття
елемента інтерфейсу, який створює `flatpickr`. Саме в ньому варто обробляти
дату, обрану користувачем. Параметр `selectedDates` — це масив обраних дат, тому
ми беремо перший елемент `selectedDates[0]`.

Тобі ця обрана дата буде потрібна в коді і поза межами цього методу `onClose()`.
Тому оголоси поза межами методу `let` змінну, наприклад, `userSelectedDate`, і
після валідації її в методі `onClose()` на минуле/майбутнє запиши обрану дату в
цю `let` змінну.

- Якщо користувач вибрав дату в минулому, покажи `window.alert()` з текстом
  `"Please choose a date in the future"` і зроби кнопку `«Start»` не активною.
- Якщо користувач вибрав валідну дату (в майбутньому), кнопка `«Start»` стає
  активною.
- Кнопка `«Start»` повинна бути неактивною доти, доки користувач не вибрав дату
  в майбутньому.
- Зверни увагу, що при обранні валідної дати, не запуску таймера і обранні потім
  невалідної дати, кнопка після розблокування має знову стати неактивною.
- Натисканням на кнопку `«Start»` починається зворотний відлік часу до обраної
  дати з моменту натискання.

#### Відлік часу

Натисканням на кнопку `«Start»` скрипт повинен обчислювати раз на секунду,
скільки часу залишилось до вказаної дати, і оновлювати інтерфейс таймера,
показуючи чотири цифри: дні, години, хвилини і секунди у форматі `xx:xx:xx:xx`.

- Кількість днів може складатися з більше, ніж двох цифр.
- Таймер повинен зупинятися, коли дійшов до кінцевої дати, тобто залишок часу
  дорівнює нулю `00:00:00:00`.

  > **Після запуску таймера натисканням кнопки Старт кнопка Старт і інпут стають
  > неактивним, щоб користувач не міг обрати нову дату, поки йде відлік часу.
  > Якщо таймер запущений, для того щоб вибрати нову дату і перезапустити його —
  > необхідно перезавантажити сторінку.**

Для підрахунку значень використовуй готову функцію `convertMs`, де `ms` —
різниця між кінцевою і поточною датою в мілісекундах.

```js
function convertMs(ms) {
  // Number of milliseconds per unit of time
  const second = 1000;
  const minute = second * 60;
  const hour = minute * 60;
  const day = hour * 24;

  // Remaining days
  const days = Math.floor(ms / day);
  // Remaining hours
  const hours = Math.floor((ms % day) / hour);
  // Remaining minutes
  const minutes = Math.floor(((ms % day) % hour) / minute);
  // Remaining seconds
  const seconds = Math.floor((((ms % day) % hour) % minute) / second);

  return { days, hours, minutes, seconds };
}

console.log(convertMs(2000)); // {days: 0, hours: 0, minutes: 0, seconds: 2}
console.log(convertMs(140000)); // {days: 0, hours: 0, minutes: 2, seconds: 20}
console.log(convertMs(24140000)); // {days: 0, hours: 6 minutes: 42, seconds: 20}
```

#### Форматування часу

Функція `convertMs()` повертає об'єкт з розрахованим часом, що залишився до
кінцевої дати. Зверни увагу, що вона не форматує результат. Тобто якщо
залишилося 4 хвилини або будь-якої іншої складової часу, то функція поверне 4, а
не 04. В інтерфейсі таймера необхідно додавати 0, якщо в числі менше двох
символів. Напиши функцію, наприклад `addLeadingZero(value)`, яка використовує
метод рядка `padStart()` і перед відмальовуванням інтерфейсу форматує значення.

#### Бібліотека повідомлень

Для відображення повідомлень користувачеві, замість `window.alert()`,
використовуй бібліотеку [iziToast](https://izitoast.marcelodolza.com/). Для того
щоб підключити CSS код бібліотеки в проєкт, необхідно додати ще один імпорт,
крім того, що описаний у документації.

```js
// Описаний у документації
import iziToast from 'izitoast';
// Додатковий імпорт стилів
import 'izitoast/dist/css/iziToast.min.css';
```

#### На що буде звертати увагу ментор при перевірці:

- Підключені бібліотеки `flatpickr` та `iziToast`.
- При першому завантаженні сторінки кнопка `Start` не активна.
- При кліку на інпут відкривається календар, де можна вибрати дату.
- При обранні дати з минулого, кнопка `Start` стає неактивною і з'являється
  повідомлення з текстом `"Please choose a date in the future"`.
- При обранні дати з майбутнього кнопка `Start` стає активною.
- При натисканні на кнопку `Start` вона стає неактивною, на сторінку виводиться
  час, що лишився до обраної дати у форматі `xx:xx:xx:xx`, і запускається
  зворотний відлік часу до обраної дати.
- Кожну секунду оновлюється інтерфейс і показує оновлені дані часу, який
  залишився.
- Таймер зупиняється, коли доходить до кінцевої дати, тобто залишок часу
  дорівнює нулю і інтерфейс виглядає так `00:00:00:00`.
- Час в інтерфейсі відформатований і, якщо воно містить менше двох символів, на
  початку числа доданий 0.

## Завдання 2 - Генератор промісів

Виконуй це завдання у файлах `2-snackbar.html` і `2-snackbar.js`. Подивися
демовідео роботи генератора промісів.




https://github.com/NelliDiachkina/goit-js-hw-10/assets/99911692/f692f0b9-eac8-4d57-aa1a-f02cb3129705





Додай в HTML файл розмітку форми. Форма складається з поля вводу для введення
значення затримки в мілісекундах, двох радіокнопок, які визначають те, як
виконається проміс, і кнопки з типом `submit`, при кліку на яку має створюватися
проміс.

```js
<form class="form">
  <label>
    Delay (ms)
    <input type="number" name="delay" required />
  </label>

  <fieldset>
    <legend>State</legend>
    <label>
      <input type="radio" name="state" value="fulfilled" required />
      Fulfilled
    </label>
    <label>
      <input type="radio" name="state" value="rejected" required />
      Rejected
    </label>
  </fieldset>

  <button type="submit">Create notification</button>
</form>
```

Напиши скрипт, який після сабміту форми створює проміс. В середині колбека цього
промісу через вказану користувачем кількість мілісекунд проміс має виконуватися
(при fulfilled) або відхилятися (при rejected), залежно від обраної опції в
радіокнопках. Значенням промісу, яке передається як аргумент у методи
resolve/reject, має бути значення затримки в мілісекундах.

Створений проміс треба опрацювати у відповідних для вдалого/невдалого виконання
методах.

Якщо проміс виконується вдало, виводь у консоль наступний рядок, де `delay` — це
значення затримки виклику промісу в мілісекундах.

```js
`✅ Fulfilled promise in ${delay}ms`;
```

Якщо проміс буде відхилено, то виводь у консоль наступний рядок, де `delay` — це
значення затримки промісу в мілісекундах.

```js
`❌ Rejected promise in ${delay}ms`;
```

#### Бібліотека повідомлень

Для відображення повідомлень, замість `console.log()`, використовуй бібліотеку
[iziToast](https://izitoast.marcelodolza.com/). Для того щоб підключити CSS код
бібліотеки в проєкт, необхідно додати ще один імпорт, крім того, що описаний у
документації.

```js
// Описаний у документації
import iziToast from 'izitoast';
// Додатковий імпорт стилів
import 'izitoast/dist/css/iziToast.min.css';
```

#### На що буде звертати увагу ментор при перевірці:

- Підключена бібліотека iziToast.
- При обранні стану в радіокнопках і натисканні на кнопку `Create notification`
  з'являється повідомлення, відповідного до обраного стану стилю, із затримкою в
  кількість мілісекунд, переданих в інпут.
- Повідомлення, що виводиться, містить тип обраного стейту і кількість
  мілісекунд згідно з шаблоном в умові.
